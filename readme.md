# konfhw — язык конфигураций + парсер, трансформер и вычислитель констант

Этот проект реализует простой конфигурационный язык (DSL), поддерживающий числа, строки, массивы, объявления констант и вычисление констант на этапе трансляции.  
Язык разработан по формальной грамматике Lark и использует три основных компонента:

- **parser** — синтаксический анализ текста  
- **transformer** — преобразование дерева разбора в удобную структуру  
- **evaluator** — выполнение и вычисление констант  

Проект обрабатывает входные файлы конфигурации, очищает их от комментариев, парсит, вычисляет значения констант и выводит финальную структуру данных.

---

# Архитектура проекта

```
    grammar.lark        # формальная грамматика языка
    parser.py           # синтаксический анализ входного текста
    transformer.py      # преобразование дерева в Python-структуру
    evaluator.py        # вычисление констант, подстановка значений
    test.py             # запуск всей цепочки на тестовых файлах
    text1.txt           # тест №1
    text2.txt           # тест №2
    text3.txt           # тест №3
```

### Краткое описание ролей файлов:

| Файл | Назначение |
|------|------------|
| **grammar.lark** | Описание синтаксиса языка. |
| **parser.py** | Чтение грамматики, удаление комментариев, построение AST. |
| **transformer.py** | Превращает дерево AST в удобные кортежи Python. |
| **evaluator.py** | Вычисляет константы, раскрывает массивы, выполняет рекурсивную обработку. |
| **test.py** | Запускает обработку text1.txt/text2.txt/text3.txt. |
| **text1/2/3.txt** | Реальные конфигурации для демонстрации работы языка. |

---

# Общее описание языка

Язык поддерживает следующие конструкции:

### Числа  
Натуральные числа вида:

```
10
42
5
```

### Строки  
Используется стандартная строка в кавычках:

```
"hello"
"DB"
"text"
```

### Массивы  
Массив задаётся конструкцией:

```
'( 1 2 3 )
'( "apple" "banana" )
'( ^{X} ^{Y} )
```

### Объявление константы

```
NAME <- значение;
```

Например:

```
A <- 10;
TEXT <- "hello";
ARR <- '( 1 2 3 );
```

### Использование константы

```
^{NAME}
```

Например:

```
^{A}
^{TEXT}
^{ARR}
```

### Комментарии

- Однострочные:

```
REM это комментарий
```

- Многострочные:

```
{{!--
  много строк
--}}
```

---

# Как работает `parser.py`

`parser.py` выполняет:

1. Чтение grammar.lark
2. Удаление комментариев из входного текста:
   - `REM ...`  
   - `{{!-- ... --}}`
3. Построение синтаксического дерева (`Tree`) через Lark

Результат — дерево вида:

```
start
  item
    const_def
      A
      value 10
```

---

# Как работает `transformer.py`

Transformer проходится по дереву и заменяет узлы Tree на обычные структуры Python:

### Примеры преобразований:

| Было (AST Tree) | Становится (кортеж) |
|-----------------|---------------------|
| `NUMBER` | `("number", 10)` |
| `string` | `("string", "hello")` |
| `array` | `("array", [...])` |
| `const_def` | `("const_def", name, value)` |
| `const_use` | `("const_use", "A")` |
| `item` | просто содержимое |

Главная задача transformer — превратить дерево в компактное структурированное представление:

```
("start", [ ... ])
```

---

# Как работает `evaluator.py`

Evaluator получает структуру после трансформации и выполняет:

## 1. Сбор констант
Каждый `const_def` преобразуется в:

```
{"A": ("number", 10), ...}
```

При этом значения вычисляются рекурсивно, включая вложенные массивы.

## 2. Вычисление:
- раскрытие `("const_use", name)`
- глубокое копирование значений констант
- рекурсивный обход внутренних массивов

## 3. Замена всех констант в финальном выводе

Константы сами по себе **не выводятся** — вместо них выводится `None`.

---

# Примеры входных файлов

## text1.txt
```
REM простой тест

A <- 10;
B <- "hello";

'( 1 2 3 )
"test"
^{A}
^{B}
```

## text2.txt
```
{{!--
  многострочный комментарий
--}}

ARR <- '( 100 200 300 );

ITEMS <- '( "apple" "banana" "cherry" );

'( ^{ARR} ^{ITEMS} 42 )
```

## text3.txt
```
REM объявляем константы
X <- 5;
Y <- 15;

{{!-- проверяем данные --}}

NAME <- "DB";

VALUES <- '( 1 2 '( 3 4 ^{X} ) "text" );

'( 
    ^{NAME}
    ^{VALUES}
    '( ^{X} ^{Y} )
)
```

---

# Результаты обработки

### text1.txt
```
[None, None, ('array', [('number', 1), ('number', 2), ('number', 3)]),
 ('string', 'test'),
 ('number', 10),
 ('string', 'hello')]
```

### text2.txt
```
[None, None, ('array', [
    ('array', [('number', 100), ('number', 200), ('number', 300)]),
    ('array', [('string', 'apple'), ('string', 'banana'), ('string', 'cherry')]),
    ('number', 42)
])]
```

### text3.txt
```
[None, None, None, None,
 ('array', [
     ('string', 'DB'),
     ('array', [
         ('number', 1),
         ('number', 2),
         ('array', [('number', 3), ('number', 4), ('number', 5)]),
         ('string', 'text')
     ]),
     ('array', [('number', 5), ('number', 15)])
 ])]
```

---


# Вывод

Выполнил задачи по проекту:   

- собственный конфигурационный язык
- формальную грамматику Lark
- синтаксический анализ (parser)
- преобразование AST (transformer)
- рекурсивный вычислитель констант (evaluator)
- тестовый стенд на 3 файлах

Работа даёт устойчивое понимание:
- построения DSL
- работы парсеров
- трансформации AST
- интерпретации значений
